<!DOCTYPE html> <html> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta name="author" content=""> <title>Fibrations in agda</title> <link rel='alternate' type='application/atom+xml' title='Atom feed for http://localhost:4000' href='/atom.xml'> <link rel="icon" type="image/png" href="assets/favicon.png"> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" /> <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link rel="stylesheet" href="https://fonts.googleapis.com/css?display=swap&family=Lato|Oswald|Noto+Color+Emoji"/> <link rel="stylesheet" href="css/main.css"/> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css" integrity="sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb" crossorigin="anonymous" /> <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js" integrity="sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h" crossorigin="anonymous"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/contrib/auto-render.min.js" integrity="sha384-cXpztMJlr2xFXyDSIfRWYSMVCXZ9HeGXvzyKTYrn03rsMAlOtIQVzjty5ULbaP8L" crossorigin="anonymous"></script> <script> document.addEventListener("DOMContentLoaded", function() { renderMathInElement( document.body, { delimiters: [ {left: "$$", right: "$$", display: true}, {left: "\\[", right: "\\]", display: true}, {left: "$", right: "$", display: false}, {left: "\\(", right: "\\)", display: false} ] } ); }); </script> </head> <body> <h1 id="fibrations-in-agda">Fibrations in agda</h1> <p>(Note: this is a literate agda file: <a href="stuff/simple.lagda.md">src</a>)</p> <p>I have recently decided to iron all the kinks of a few proofs left as exercises in Bart Jacobsâ€™ book <em>Categorical logic and type theory</em>, by proving them in agda (and in particular, using <a href="https://github.com/agda/agda-categories">agda-categories</a>).</p> <p>The first obligatory step is some boilerplate code: letâ€™s keep this to a minimum.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module simple {I : Set} where

open import Categories.Category
open import Categories.Category.Cartesian.Bundle
open import Categories.Category.CartesianClosed.Canonical
open import Categories.Category.Core
open import Data.Product
open import Function using (const)
open import Level
open import Relation.Binary.Core using (Rel)
open import Relation.Binary.PropositionalEquality
open Relation.Binary.PropositionalEquality.â‰¡-Reasoning
open import Categories.Functor
open import Categories.Functor.Bifunctor
open import Categories.Comonad
open import Categories.Category.Construction.CoEilenbergMoore
open import Categories.NaturalTransformation as NT using (ntHelper)
open import Categories.NaturalTransformation.NaturalIsomorphism hiding (refl; sym; trans)
import Categories.Category.Equivalence as E

private
  variable
    a b c : Level

-- I have to redefine function composition. A rename or this will do:
_â‹†_ : âˆ€ {A : Set a} {B : A â†’ Set b} {C : {x : A} â†’ B x â†’ Set c} â†’
      (âˆ€ {x} (y : B x) â†’ C y) â†’ (g : (x : A) â†’ B x) â†’
      ((x : A) â†’ C (g x))
f â‹† g = Î» x â†’ f (g x)
</code></pre></div></div> <p>and next, the terminal type, and a lemma that says it has only one term (some proofs of uniqueness require extensionality plus this lemma):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data t : Set where
 âŠ¤ : t

!-unique-lemma : âˆ€ (x : t) â†’ âŠ¤ â‰¡ x
!-unique-lemma âŠ¤ = refl

postulate
 -- we need to postulate extensionality...
 extensionality : âˆ€ {A B : Set} {f g : A â†’ B} â†’
  (âˆ€ (x : A) â†’ f x â‰¡ g x) â†’ f â‰¡ g

-- and a proof that the category of Sets is indeed a category.
SetC : Category (suc zero) zero zero
-- a category depends on three levels:
-- 1. where the objects live,
-- 2. where the hom-set(oid)s live,
-- 3. and where the category lives.
SetC =
 record
  { Obj = Set
  -- the class of objects
  ; _â‡’_ = Î» x y â†’ x â†’ y
  -- the relation defining the hom-setoids.
  ; _â‰ˆ_ = _â‰¡_
  -- def of equality in the homs
  ; id = Î» x â†’ x
  -- the identity function
  ; _âˆ˜_ = Î» f g a â†’ f (g a)
  -- category composition
  ; assoc = refl
  ; sym-assoc = refl
  -- two proofs of associativity: this makes (C^op)^op
  -- syntactically equal to C, which is nice
  ; identityË¡ = refl
  ; identityÊ³ = refl
  ; identityÂ² = refl
  -- proofs that id . f = f = f . id and id . id = id
  ; equiv = record { refl = refl ; sym = sym ; trans = trans }
  -- proof that _â‰ˆ_ is an equivalence relation...
  ; âˆ˜-resp-â‰ˆ = Î» {refl refl â†’ refl}
  -- and a congruence with respect to composition.
  }
</code></pre></div></div> <p>Everything is quite trivial here; the comments I added clarify how the various records have to be filled. Probably one of the most useful tricks to learn here, is the way in which the last field was filled: I didnâ€™t know about the existence of this when I first opened this file, and it really saved me hours.</p> <p>Now, one of the first interesting examples in Jacobsâ€™ book is that of a <em>simple fibration</em> over a category ğ”¹ with finite products (letâ€™s say, all finite limits, and for fibration-theory purposes, even a <em>canonical</em> choice thereof).</p> <p>Given such a category ğ”¹, the category s(ğ”¹) is defined having</p> <ol> <li>objects the pairs <code class="language-plaintext highlighter-rouge">(I , X)</code> of objects in ğ”¹;</li> <li>morphisms <code class="language-plaintext highlighter-rouge">(I , X) â†’ (J , Y)</code> are pairs of morphisms <code class="language-plaintext highlighter-rouge">u : I â†’ J</code> and <code class="language-plaintext highlighter-rouge">f : I Ã— X â†’ Y</code>.</li> </ol> <p>The identity is the â€œtrivialâ€ pair made by the couple <code class="language-plaintext highlighter-rouge">(id {I} , projâ‚‚)</code> (the projection on the second factor). The composition of <code class="language-plaintext highlighter-rouge">(u , f)</code> and <code class="language-plaintext highlighter-rouge">(v , g)</code> is defined as <code class="language-plaintext highlighter-rouge">(v âˆ˜ u , g âˆ˜ âŸ¨ u âˆ˜ projâ‚ , f âŸ©)</code>, and all the other choices are either forced by this, or straightforward (for example, <code class="language-plaintext highlighter-rouge">_â‰ˆ_</code> is just <code class="language-plaintext highlighter-rouge">_â‰¡_</code>).</p> <p>Fortunately, agda needs just a little bit of help to figure everything out.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>simple : Category (suc zero) zero zero
simple =
 record
  -- structure
  { Obj = Set Ã— Set
  ; _â‡’_ = _â‡’_
  ; _â‰ˆ_ = _â‰¡_
  ; id = (Î» z â†’ z) , projâ‚
  ; _âˆ˜_ = _âˆ˜_
  -- properties
  ; assoc = refl
  ; sym-assoc = refl
  ; identityË¡ = refl
  ; identityÊ³ = refl
  ; identityÂ² = refl
  -- whew, they're all trivial!
  ; equiv = record { refl = refl ; sym = sym ; trans = trans }
  ; âˆ˜-resp-â‰ˆ = Î» {refl refl â†’ refl}
  }
  where
  _â‡’_ : Rel (Set Ã— Set) zero
  (i , x) â‡’ (j , y) = (i â†’ j) Ã— (x Ã— i â†’ y)
  _âˆ˜_ : {A B C : Set Ã— Set} â†’ B â‡’ C â†’ A â‡’ B â†’ A â‡’ C
  _âˆ˜_ {i , x} {j , y} {_} (u , f) (v , g) =
   (Î» t â†’ u (v t)) , Î» t â†’ f (g t , v (projâ‚‚ t))
</code></pre></div></div> <p>Now, <code class="language-plaintext highlighter-rouge">s(ğ”¹)</code> comes equipped with an obvious forgetful functor to ğ”¹, projecting on the first component: the object of interest for Jacobsâ€™ is the fiber of this functor over a certain <code class="language-plaintext highlighter-rouge">I âˆˆ ğ”¹</code>. Such a category can be characterised in many ways; the most elegant is: it is a certain Kleisli category.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fiber-of-simple : {I : Set} â†’ Category (suc zero) zero zero
fiber-of-simple {I} =
 record
  { Obj = Set
  ; _â‡’_ = Î» X Y â†’ X Ã— I â†’ Y
  ; _â‰ˆ_ = _â‰¡_
  ; id = projâ‚
  ; _âˆ˜_ = _Â·_ -- this is the Kleisli composition
  ; assoc = refl
  ; sym-assoc = refl
  ; identityË¡ = refl
  ; identityÊ³ = refl
  ; identityÂ² = refl
  ; equiv = record { refl = refl ; sym = sym ; trans = trans }
  ; âˆ˜-resp-â‰ˆ = rresp
  }
  where
   _Â·_ : {I : Set} {A B C : Set} â†’ (B Ã— I â†’ C) â†’ (A Ã— I â†’ B) â†’ A Ã— I â†’ C
   _Â·_ {I} f g (x , i) = f (g(x , i) , i)
   rresp : {A B C : Set} {f h : B Ã— I â†’ C} {g i : A Ã— I â†’ B} â†’
    f â‰¡ h â†’ g â‰¡ i â†’ (f Â· g) â‰¡ (h Â· i)
   rresp {A} {B} {C} {f} {h} {g} {i} x y =
    trans (cong (Î» t â†’ t Â· g) x) (cong (_Â·_ h) y)
</code></pre></div></div> <p>The proof that reindexing functors exist:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reindex : {I J : Set} â†’
 (u : I â†’ J) â†’
 Functor (fiber-of-simple {J}) (fiber-of-simple {I})
reindex {I} {J} u = record
  { Fâ‚€ = F0
  ; Fâ‚ = F1
  ; identity = refl
  ; homomorphism = refl
  ; F-resp-â‰ˆ = Î» {refl â†’ refl}
  }
  where
  open Category (fiber-of-simple {J})
  F0 : Obj â†’ Set
  F0 X = X Ã— J
  F1 : {A B : Obj} â†’
   (fiber-of-simple {J}) Categories.Category.[ A , B ] â†’
   (fiber-of-simple {I}) Categories.Category.[ F0 A , F0 B ]
  F1 {A} {B} u ((a , j) , i) = u (a , j) , j
</code></pre></div></div> <p>Now, hereâ€™s the proof that each fiber of a simple fibration is cartesian.</p> <p>It is moderately painful, because the record <code class="language-plaintext highlighter-rouge">CartesianCategory</code> has other records nested insideâ€¦</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fib-of-simple-cartesian : âˆ€ {I : Set} â†’
 CartesianCategory (suc zero) zero zero
fib-of-simple-cartesian {I} =
 record
  { U = fiber-of-simple {I}
  ; cartesian =
    record
     { terminal =
       record { âŠ¤ = t
           ; âŠ¤-is-terminal =
             record
              { ! = const âŠ¤
              ; !-unique =
                Î» f â†’ extensionality (Î» x â†’ !-unique-lemma (f x))
              }
           }
     ; products =
       record
        { product = Î» {A} {B} â†’
          record
           { AÃ—B = A Ã— B
           ; Ï€â‚ = Î» x â†’ projâ‚ (projâ‚ x)
           ; Ï€â‚‚ = Î» x â†’ projâ‚‚ (projâ‚ x)
           ; âŸ¨_,_âŸ© = Î» f g t â†’ f t , g t
           ; projectâ‚ = refl
           ; projectâ‚‚ = refl
           ; unique = Î» {refl refl â†’ refl}
           } } } }
</code></pre></div></div> <p>but with a little help from our friend <code class="language-plaintext highlighter-rouge">Î» {refl ... refl â†’ refl}</code>, we did it!</p> <p>Mimicking the same argument, just not restricted to the fiber at <code class="language-plaintext highlighter-rouge">I</code>, one proves that the entire s(ğ”¹) is a cartesian category.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>simple-cartesian : CartesianCategory (suc zero) zero zero
simple-cartesian = record
 { U = simple
 ; cartesian = record
   { terminal = record
    { âŠ¤ = t , t
    ; âŠ¤-is-terminal =
      record { ! = const âŠ¤ , const âŠ¤
             ; !-unique = bang-uniq
             } }
   ; products = record { product = Î» {A} {B} â†’ record
    { AÃ—B = (projâ‚ A Ã— projâ‚ B) , (projâ‚‚ A Ã— projâ‚‚ B)
    ; Ï€â‚ = projâ‚ , Î» x â†’ projâ‚ (projâ‚ x)
    ; Ï€â‚‚ = projâ‚‚ , (Î» x â†’ projâ‚‚ (projâ‚ x))
    ; âŸ¨_,_âŸ© = âŸ¨_,_âŸ©
    ; projectâ‚ = refl
    ; projectâ‚‚ = refl
    ; unique = Î» {refl refl â†’ refl}
    } } } }
    where
     open Category simple
     bang-uniq :
      {A : Obj}
      -------------------------
      (f : A â‡’ (t , t)) â†’
      --------------------------------------
      (simple Category.â‰ˆ (const âŠ¤ , const âŠ¤)) f
     bang-uniq {I , X} (u , k) =
      congâ‚‚ Data.Product._,_
       (extensionality (Î» x â†’ !-unique-lemma (u x)))
       (extensionality (Î» x â†’ !-unique-lemma (k x)))
     âŸ¨_,_âŸ© :
      {A B C : Set Ã— Set} â†’
      C â‡’ A â†’
      C â‡’ B â†’
      C â‡’ ((projâ‚ A Ã— projâ‚ B) , (projâ‚‚ A Ã— projâ‚‚ B))
     âŸ¨_,_âŸ© {A0 , A1} {B0 , B1} {C0 , C1} (u , h) (v , k) =
      (Î» x â†’ (u x) , (v x)) , Î» x â†’ (h x) , (k x)
</code></pre></div></div> <p>â€¦the biggest pain was to indent the code in a logical way.</p> <p>And now for the proof that each fiber of <code class="language-plaintext highlighter-rouge">U : s(ğ”¹) â†’ ğ”¹</code> is cartesian closed:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fib-of-simple-ccc : {I : Set} â†’ CartesianClosed (fiber-of-simple {I})
fib-of-simple-ccc {I} =
 record
  { âŠ¤ = t
  ; _Ã—_ = _Ã—_
  ; ! = Î» x â†’ âŠ¤
  ; Ï€â‚ = projâ‚ â‹† projâ‚
  ; Ï€â‚‚ = projâ‚‚ â‹† projâ‚
  ; âŸ¨_,_âŸ© = Î» f g ci â†’ (f ci) , (g ci)
  ; !-unique = Î» f â†’ extensionality Î» x â†’ !-unique-lemma (f x)
  ; Ï€â‚-comp = refl
  ; Ï€â‚‚-comp = refl
  ; âŸ¨,âŸ©-unique = Î» {refl refl â†’ refl}
  ; _^_ = Î» A B â†’ B â†’ A
  ; eval = evev
  ; curry = Î» f ci a â†’ f (((projâ‚ ci) , a) , (projâ‚‚ ci))
  ; eval-comp = refl
  ; curry-resp-â‰ˆ = Î» {refl â†’ refl}
  ; curry-unique = Î» {refl â†’ refl}
  }
  where
  open Category (fiber-of-simple {I})
  evev : {B A : Obj} â†’ ((A â†’ B) Ã— A) â‡’ B
  evev ((f , a) , i) = f a
</code></pre></div></div> <p>Another interesting exercise is the following: for every category with finite products, the categories <code class="language-plaintext highlighter-rouge">ğ”¹//I</code> and <code class="language-plaintext highlighter-rouge">ğ”¹/I</code> admit equivalent presentations as, respectively, the coKleisli and the coEilenberg-Moore categories of the comonad <code class="language-plaintext highlighter-rouge">_ Ã— I</code>.</p> <p>First, letâ€™s summon the <code class="language-plaintext highlighter-rouge">Comonad</code> module:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open import Categories.Comonad
</code></pre></div></div> <p>and prove that the functor <code class="language-plaintext highlighter-rouge">_ Ã— I</code> is a comonad, providing all the structure.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â”€Ã—_ : (I : Set) â†’ Comonad SetC
â”€Ã— I =
 record
  { F = F {I}
  ; Îµ = eps
  ; Î´ = comul
  ; assoc = refl
  ; sym-assoc = refl
  ; identityË¡ = refl
  ; identityÊ³ = refl
  }
  where
  F : {I : Set} â†’ Endofunctor SetC
  F {I} =
   record
    { Fâ‚€ = Î» A â†’ A Ã— I
    ; Fâ‚ = Î» f x â†’ (f (projâ‚ x)) , (projâ‚‚ x)
    ; identity = refl
    ; homomorphism = refl
    ; F-resp-â‰ˆ = Î» {refl â†’ refl}
    }
  eps : NT.NaturalTransformation (F {I}) Categories.Functor.id
  eps =
   record
    { Î· = Î» X x â†’ projâ‚ x
    ; commute = Î» f â†’ refl
    ; sym-commute = Î» f â†’ refl }
  comul : NT.NaturalTransformation (F {I}) ((F {I}) âˆ˜F (F {I}))
  comul =
   record
    { Î· = Î» X x â†’ x , projâ‚‚ x
    ; commute = Î» f â†’ refl
    ; sym-commute = Î» f â†’ refl }
</code></pre></div></div> <p>Easy as co-pie! Now, where is the <code class="language-plaintext highlighter-rouge">coKleisli</code> moduleâ€¦? Oh, you say you donâ€™t have it yet.</p> <p>[â€¦a few weeks of frantic, painful agda sessions laterâ€¦]</p> <p>tada!</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open import Categories.Category.Construction.CoKleisli

fiber-of-simpleâ‰ƒCoKleisliâ”€Ã—I : {I : Set} â†’
  E.StrongEquivalence (fiber-of-simple {I}) (CoKleisli (â”€Ã— I))
fiber-of-simpleâ‰ƒCoKleisliâ”€Ã—I = record
 { F = F
 ; G = G
 ; weak-inverse = winv
 }
 where
 F : {I : Set} â†’ Functor (fiber-of-simple {I}) (CoKleisli (â”€Ã— I))
 F = record
      { Fâ‚€ = Î» A â†’ A
      ; Fâ‚ = Î» f â†’ f
      ; identity = refl
      ; homomorphism = refl
      ; F-resp-â‰ˆ = Î» x â†’ x
      }
 G : {I : Set} â†’ Functor (CoKleisli (â”€Ã— I)) (fiber-of-simple {I})
 G = record
      { Fâ‚€ = Î» z â†’ z
      ; Fâ‚ = Î» f â†’ f
      ; identity = refl
      ; homomorphism = refl
      ; F-resp-â‰ˆ = Î» x â†’ x
      }
 winv : {I : Set} â†’ E.WeakInverse (F {I}) G
 winv = record
  { Fâˆ˜Gâ‰ˆid = niHelper (record
    { Î· = Î» X â†’ projâ‚
    ; Î·â»Â¹ = Î» X â†’ projâ‚
    ; commute = Î» f â†’ refl
    ; iso = Î» X â†’ record { isoË¡ = refl ; isoÊ³ = refl } })
  ; Gâˆ˜Fâ‰ˆid = niHelper (record
    { Î· = Î» X x â†’ projâ‚ x
    ; Î·â»Â¹ = Î» X x â†’ projâ‚ x
    ; commute = Î» f â†’ refl
    ; iso = Î» X â†’ record { isoË¡ = refl ; isoÊ³ = refl } })
  }

</code></pre></div></div> <p>The meat of the proof is in proving that the ordinary slice <code class="language-plaintext highlighter-rouge">ğ”¹/I</code> is the coEilenberg-Moore category of the <code class="language-plaintext highlighter-rouge">-Ã—I</code> comonad:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open import Categories.Category.Construction.CoEilenbergMoore
open import Categories.Category.Slice SetC

Sliceâ‰ƒCoEilenbergMooreâ”€Ã—I : {I : Set} â†’
  E.StrongEquivalence (Slice I) (CoEilenbergMoore (â”€Ã— I))
Sliceâ‰ƒCoEilenbergMooreâ”€Ã—I {I} = record
  { F = F
  ; G = G
  ; weak-inverse = winv
  }
  where
  F : Functor (Slice I) (CoEilenbergMoore (â”€Ã— I))
  F = record
   { Fâ‚€ = Î» { (sliceobj {Y} arr) â†’
     record { A = Y
            ; coaction = Î» z â†’ z , arr z
            ; commute = refl
            ; identity = refl } }
   ; Fâ‚ = Î» { (slicearr {h} Î”) â†’ record
     { arr = Î» x â†’ h x
     ; commute = cong (Î» x xâ‚ â†’ h xâ‚ , x xâ‚) Î”  } }
   ; identity = refl
   ; homomorphism = refl
   ; F-resp-â‰ˆ = Î» { refl â†’ refl }
   }
  G : Functor (CoEilenbergMoore (â”€Ã— I)) (Slice I)
  G = record
   { Fâ‚€ = Î» { record
     { A = A
     ; coaction = coaction
     ; commute = commute
     ; identity = identity
     } â†’ sliceobj Î» x â†’ projâ‚‚ (coaction x) }
   ; Fâ‚ = Î» { record
     { arr = arr
     ; commute = commute
     } â†’ slicearr {h = arr} (cong (Î» x xâ‚ â†’ projâ‚‚ (x xâ‚)) commute) }
   ; identity = refl
   ; homomorphism = refl
   ; F-resp-â‰ˆ = Î» { refl â†’ refl }
   }
  winv : E.WeakInverse F G
  winv = record
   { Fâˆ˜Gâ‰ˆid = niHelper (record
     { Î· = Î» { record
       { A = A
       ; coaction = coaction
       ; commute = commute
       ; identity = identity
       } â†’ record { arr = Î» a â†’ projâ‚ (coaction a)
                  ; commute = cong (Î» x xâ‚ â†’ coaction (x xâ‚)) identity } }
     ; Î·â»Â¹ = Î» { record
       { A = A
       ; coaction = coaction
       ; commute = commute
       ; identity = identity
       } â†’ record { arr = Î» z â†’ z
                  ; commute =
                    cong (Î» x xâ‚ â†’ x xâ‚ , projâ‚‚ (coaction xâ‚) ) (sym identity) } }
     ; commute = Î» { record
       { arr = arr
       ; commute = commute
       } â†’ cong (Î» x xâ‚ â†’ projâ‚ (x xâ‚)) commute }
     ; iso = Î» { record
       { A = A
       ; coaction = coaction
       ; commute = commute
       ; identity = identity
       } â†’ record { isoË¡ = identity ; isoÊ³ = identity } }
     })
   ; Gâˆ˜Fâ‰ˆid = niHelper (record
     { Î· = Î» arr â†’ slicearr refl
     ; Î·â»Â¹ = Î» obj â†’ slicearr refl
     ; commute = Î» arr â†’ refl
     ; iso = Î» X â†’ record { isoË¡ = refl ; isoÊ³ = refl }
     })
   }
</code></pre></div></div> <script type="text/javascript" src="js/jquery.min.js"/></script> <script type="text/javascript" src="js/jquery.scrollme.min.js"/></script> <script type="text/javascript" src="js/stickUp.min.js"/></script> <script type="text/javascript" src="js/fchoue.js"/></script> <script type="text/javascript" src="js/bibtex-copy-button.js"/></script> </body> </html>
