<!DOCTYPE html> <html> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta name="author" content=""> <title>Category Theory and Applications (2024-02-15) - Practice session</title> <link rel='alternate' type='application/atom+xml' title='Atom feed for http://localhost:4000' href='/atom.xml'> <link rel="icon" type="image/png" href="assets/favicon.png"> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" /> <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link rel="stylesheet" href="https://fonts.googleapis.com/css?display=swap&family=Lato|Oswald|Noto+Color+Emoji"/> <link rel="stylesheet" href="css/main.css"/> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css" integrity="sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb" crossorigin="anonymous" /> <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js" integrity="sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h" crossorigin="anonymous"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/contrib/auto-render.min.js" integrity="sha384-cXpztMJlr2xFXyDSIfRWYSMVCXZ9HeGXvzyKTYrn03rsMAlOtIQVzjty5ULbaP8L" crossorigin="anonymous"></script> <script> document.addEventListener("DOMContentLoaded", function() { renderMathInElement( document.body, { delimiters: [ {left: "$$", right: "$$", display: true}, {left: "\\[", right: "\\]", display: true}, {left: "$", right: "$", display: false}, {left: "\\(", right: "\\)", display: false} ] } ); }); </script> </head> <body> <h1 id="category-theory-and-applications-2024-02-15---practice-session">Category Theory and Applications (2024-02-15) - Practice session</h1> <h2 id="todays-plan">Today’s plan</h2> <ul> <li>Introduce a small programming language</li> <li>Recap categories</li> <li>Construct a category of types and total programs</li> <li>Reason on the equality of some morphisms of the category</li> <li>Observe some properties of our category</li> <li>Introduce the category of types and partial functions</li> </ul> <h2 id="the-crust-programming-language">The Crust programming language</h2> <p>In order to introduce our example categories and see how category theory is closely linked to programming, we need to agree on a small programming language, which we now introduce. We call it the <strong>Crust</strong> language:</p> <ul> <li><strong>C</strong>ategory theory-inspired</li> <li><strong>R</strong>ust-like</li> <li><strong>U</strong>nified language</li> <li><strong>S</strong>upporting</li> <li><strong>T</strong>ypes</li> </ul> <p>We introduce the language not formally but only intuitively, by examples:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We write comments like this</span>

<span class="c1">// Some example functions</span>
<span class="k">fn</span> <span class="nf">addThree</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span>   <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">3</span>
<span class="k">fn</span> <span class="nf">isEven</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Bool</span>    <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
<span class="k">fn</span> <span class="nf">boolToInt</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Bool</span><span class="p">):</span> <span class="n">Int</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="n">a</span> <span class="n">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
<span class="k">fn</span> <span class="nf">twiceLength</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">String</span><span class="p">):</span> <span class="n">Int</span> <span class="k">=&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="nf">.length</span><span class="p">()</span> 
<span class="k">fn</span> <span class="nf">isGreaterThan18</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Bool</span> <span class="k">=&gt;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">18</span>

<span class="c1">// Convention: we will always start functions names in lowercase, and types in uppercase.</span>

<span class="c1">// Multiple arguments</span>
<span class="k">fn</span> <span class="nf">test</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">Bool</span><span class="p">):</span> <span class="n">Bool</span> <span class="k">=&gt;</span> <span class="nf">isGreaterThan18</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">a</span>

<span class="c1">// We can use a method-like syntax on the first argument of a function</span>
<span class="cm">/*
&gt; let a: Int = 7
&gt; a.addThree()
10
&gt; test(a, false)    
false
&gt; a.test(false)  
false
*/</span>
</code></pre></div></div> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Define a new type</span>
<span class="k">type</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nf">nil</span><span class="p">()</span>
             <span class="p">|</span> <span class="nf">cons</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">)</span>
<span class="cm">/*
    Something of type list can either be 
    the expression nil or the expression cons(a, b),
    where a is of type A, and b is of type List&lt;A&gt;.
*/</span>

<span class="c1">// Functions which are parametric on their type.</span>
<span class="cm">/* 
This defines a *family* of programs: there is no *single* tail function, but there is a function 
  tail&lt;Int&gt;, tail&lt;String&gt;, ..., tail&lt;A&gt;, for any type A.

fn&lt;A&gt; tail(a: List&lt;A&gt;): List&lt;A&gt; =&gt;
    match a with 
    | nil() =&gt; nil()
    | cons(x, vs) =&gt; vs
*/</span>
</code></pre></div></div> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Pairs</span>
<span class="k">type</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nf">pair</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>

<span class="k">fn</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">createCourse</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">A</span><span class="p">):</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="n">A</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="nf">pair</span><span class="p">(</span><span class="s">"category theory"</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="k">fn</span> <span class="nf">personAge</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="n">Int</span><span class="o">&gt;</span><span class="p">):</span> <span class="n">Int</span> <span class="k">=&gt;</span> 
    <span class="k">match</span> <span class="n">person</span> <span class="n">with</span>
    <span class="p">|</span> <span class="nf">pair</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">age</span> 

<span class="c1">// Method chaining</span>
<span class="k">fn</span> <span class="nf">isAdult</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="n">Int</span><span class="o">&gt;</span><span class="p">):</span> <span class="n">Bool</span> <span class="k">=&gt;</span> 
    <span class="n">person</span><span class="nf">.personAge</span><span class="p">()</span><span class="nf">.isGreaterThan18</span><span class="p">()</span>

<span class="cm">/*
In Crust, method chaining is just syntactic sugar for function application. Our last function could have equivalently been defined like this:

fn isAdult(person: Pair&lt;String,Int&gt;): Bool =&gt; 
    isGreaterThan18(personAge(person))

Notice: method chaining implicitly puts brackets on the left.

    (person.personAge()).isGreaterThan18()
    ((a.op1()).op2()).op3()

In this example, the other convention wouldn't typecheck:

    person.(personAge().isGreaterThan18())
           ^^^^^^^^^^^^^^^^^^^^^^^^^ personAge requires 1 arguments, 0 supplied.
*/</span>

<span class="c1">// Method chaining with some example functions (which take 2 arguments)</span>
<span class="k">fn</span> <span class="nf">averageAge</span><span class="p">(</span><span class="n">people</span><span class="p">:</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Pair</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="n">Int</span><span class="o">&gt;&gt;</span><span class="p">):</span> <span class="n">Float</span> <span class="k">=&gt;</span>
    <span class="n">people</span><span class="nf">.filter</span><span class="p">(</span><span class="n">isAdult</span><span class="p">)</span>
          <span class="nf">.map</span><span class="p">(</span><span class="n">personAge</span><span class="p">)</span>
          <span class="nf">.average</span><span class="p">()</span>

<span class="c1">// Note that there is no recursion in Crust.          </span>
</code></pre></div></div> <h2 id="categories-recap">Categories, recap</h2> <blockquote> <p>Whenever we write $X \in A$ we mean that $X$ is in the set $A$.</p> </blockquote> <p>As we’ve seen during the course, a category $C$ is constituted by the following data:</p> <ul> <li><em>(objects)</em> A collection of objects $C_0$,</li> <li><em>(morphisms)</em> For any two objects $A, B \in C_0$, a set of morphisms $C(A,B)$,</li> <li><em>(identities)</em> For any object $A \in C_0$, a morphism $id_A \in C(A,A)$,</li> <li><em>(composition)</em> For any two morphisms $f \in C(A,B), g \in C(B,C)$, a morphism $f\,;g \in C(A,C)$,</li> </ul> <p>Satisfying the following conditions:</p> <ul> <li><em>(identity left)</em> For any morphism $f \in C(A,B)$, we have that \(f;id_B = f\)</li> <li><em>(identity right)</em> For any morphism $f \in C(A,B)$, we have that \(id_A;f = f\)</li> <li><em>(associativity)</em> For any morphism $f \in C(A,B), g \in C(B,C), h \in C(C,D)$, we have that \((f;g);h = f;(g;h)\)</li> </ul> <p>Today we will focus on two specific categories, which we have seen during the lecture.</p> <h2 id="the-category-prog-of-types-and-crust-functions">The category <code class="language-plaintext highlighter-rouge">Prog</code> of types and Crust functions</h2> <p>The first category we define today is <code class="language-plaintext highlighter-rouge">Prog</code>, the category where objects are types, and morphisms are programs of Crust.</p> <p>As the course progresses, we will reason on more properties of our language using category theory.</p> <p>Observe that in our language <strong>Crust</strong> it is not possible to write a looping program.</p> <p>For today’s lecture, we consider the language <strong>Crust</strong> assuming the following things:</p> <ul> <li>Only <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Bool</code>, <code class="language-plaintext highlighter-rouge">String</code> types.</li> <li>Functions only take one argument.</li> <li>(No <code class="language-plaintext highlighter-rouge">List&lt;A&gt;</code>, no <code class="language-plaintext highlighter-rouge">Pair&lt;A,B&gt;</code>)</li> </ul> <p>We will encounter these types again when talking about functors and cartesian closed categories.</p> <blockquote> <p><strong>Note</strong>: types of programming languages are very similar to sets: if <code class="language-plaintext highlighter-rouge">Int</code> is a type, we can say that <code class="language-plaintext highlighter-rouge">3</code> has type <code class="language-plaintext highlighter-rouge">Int</code>, and similarly we can say that $3 \in \Z$ where $\Z = {0,1,2,…,-1,-2,-3,…}$ is the set of all integers.</p> </blockquote> <h2 id="definition-of-the-category-textprog">Definition of the category $\text{Prog}$.</h2> <ul> <li><em>(objects)</em> $\text{Prog}_0$ is the collection of all the types in our current version of <em>Crust</em>.</li> <li><em>(morphisms)</em> Given two types <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code> of <em>Crust</em>, $\text{Prog}($<code class="language-plaintext highlighter-rouge">A</code>$,$<code class="language-plaintext highlighter-rouge">B</code>) is the set of programs of <em>Crust</em> which take one argument of type <code class="language-plaintext highlighter-rouge">A</code> and have <code class="language-plaintext highlighter-rouge">B</code> as return type.</li> </ul> <blockquote> <p><strong>Note</strong>: compared to <code class="language-plaintext highlighter-rouge">Prog</code> the category <code class="language-plaintext highlighter-rouge">Set</code> of sets and functions obviously way more objects. We only have three “sets” here, the set of integers, the set of strings, and the set with two elements, $\mathbb B = {\texttt{true},\texttt{false}}$.</p> </blockquote> <blockquote> <p><strong>Note</strong>: even by considering only <code class="language-plaintext highlighter-rouge">Int</code> and <code class="language-plaintext highlighter-rouge">Bool</code>, there are morphisms in set which are not represented by programs in <code class="language-plaintext highlighter-rouge">Prog</code>: there is no terminating program <code class="language-plaintext highlighter-rouge">def halts(code: Int): Bool</code> which gives <code class="language-plaintext highlighter-rouge">true</code> when the program represented by <code class="language-plaintext highlighter-rouge">code</code> terminates and <code class="language-plaintext highlighter-rouge">false</code> otherwise.</p> </blockquote> <ul> <li><em>(identities)</em> For any given type <code class="language-plaintext highlighter-rouge">A</code>, the identity morphism $\texttt{identity}_\texttt A \in C(A,B)$ is the function <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">identity_a</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">):</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">x</span>
</code></pre></div> </div> <p>In other words, we define the following morphisms:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">identity_Int</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="k">=&gt;</span> <span class="n">x</span>
  <span class="k">fn</span> <span class="nf">identity_Str</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">String</span><span class="p">):</span> <span class="nb">String</span> <span class="k">=&gt;</span> <span class="n">x</span>
  <span class="k">fn</span> <span class="nf">identity_Bool</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Bool</span><span class="p">):</span> <span class="n">Bool</span> <span class="k">=&gt;</span> <span class="n">x</span>
</code></pre></div> </div> </li> <li><em>(composition)</em> For any two morphisms <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">):</span> <span class="n">B</span>
</code></pre></div> </div> <p>and</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">B</span><span class="p">):</span> <span class="n">C</span>
</code></pre></div> </div> <p>we define their composition to be the morphism</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">comp_f_g</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">):</span> <span class="n">C</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span><span class="nf">.g</span><span class="p">()</span>
</code></pre></div> </div> <p>Note that we put <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">g</code> in the name of the composition morphism because they are the two names of the morphisms we compose. <!-- > **Note**: the program `fn<A,B,C> compose(f: Func<A,B>, g: Func<B,C>): Func<A,C>` is not even a morphism of our current version of *Crust*, since `Func<A,B>`, for now, is not a type of our programming language. --></p> </li> </ul> <h2 id="program-equivalence">Program equivalence</h2> <p>Now we need to check that the definitions we provided satisfy the equations of a category.</p> <p><strong>Important:</strong> We define equality in our category to be <em>program equivalence</em>.</p> <blockquote> <p><strong>Program equivalence:</strong> given two types <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> two programs <code class="language-plaintext highlighter-rouge">fn f(x: A): B</code> and <code class="language-plaintext highlighter-rouge">fn g(x: A): B</code>, we say that they are <em>equal</em> (written <code class="language-plaintext highlighter-rouge">f = g</code>) when: <em>for every value <code class="language-plaintext highlighter-rouge">x</code> of type <code class="language-plaintext highlighter-rouge">A</code>, the two calls <code class="language-plaintext highlighter-rouge">f(x)</code> and <code class="language-plaintext highlighter-rouge">g(x)</code> return the same value</em>.</p> </blockquote> <p>For example, these two programs are not <em>syntactically the same</em>!</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">addA</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="k">=&gt;</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">fn</span> <span class="nf">addB</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="k">=&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">7</span>
</code></pre></div></div> <p>However, they are clearly equivalent, because they always return the same value.</p> <p>Similarly, these two programs are going to be defined very differently, and they are going to be compiled to different machine codes.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">quicksort</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span><span class="p">):</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="o">...</span>
<span class="k">fn</span> <span class="nf">mergesort</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span><span class="p">):</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="o">...</span>
</code></pre></div></div> <p>However, they are equivalent, since they return equal values for any list <code class="language-plaintext highlighter-rouge">l: List&lt;Int&gt;</code>.</p> <p><strong>How do we establish program equivalence?</strong></p> <p>In order to say when two functions are equal we introduce the notion of <em>symbolic reasoning</em>. This is an heuristic: it works to prove equality most of the times, but sometimes a stronger argument might be needed.</p> <blockquote> <p><em>Symbolic reasoning</em> to establish <code class="language-plaintext highlighter-rouge">f = g</code>:</p> <ol> <li>Assume to have a “symbolic” variable <code class="language-plaintext highlighter-rouge">x: A</code> with the type of the input.</li> <li>Start with the expression <code class="language-plaintext highlighter-rouge">f(x)</code> and with the expression <code class="language-plaintext highlighter-rouge">g(x)</code>.</li> <li>Repeat the following rules on any of the two expressions as long as necessary: <ol> <li><strong>(Function evaluation)</strong> <em>Given a function <code class="language-plaintext highlighter-rouge">fn f(x: A): B =&gt; ...</code> and a value <code class="language-plaintext highlighter-rouge">v: A</code>, we can evaluate the expression <code class="language-plaintext highlighter-rouge">f(v)</code> by taking the body of the function and replacing the variable <code class="language-plaintext highlighter-rouge">x</code> with the value <code class="language-plaintext highlighter-rouge">v</code>. For example, the expression <code class="language-plaintext highlighter-rouge">addA(42)</code> can be unfolded to <code class="language-plaintext highlighter-rouge">4 + (42 + 3)</code>.</em></li> <li><strong>(General rule.)</strong> Apply any equivalence which is valid because of general reasons. For example, given <code class="language-plaintext highlighter-rouge">a, b: Int</code>, we can replace <code class="language-plaintext highlighter-rouge">a + b</code> with <code class="language-plaintext highlighter-rouge">b + a</code> because addition is commutative.</li> <li><strong>(Match evaluation.)</strong> <em>(Not needed for now.)</em> …</li> <li><strong>(Case analysis.)</strong> <em>(Not needed for now.)</em> …</li> </ol> </li> <li>Repeat step 3. until the two expressions match <em>syntactically</em>.</li> </ol> </blockquote> <h3 id="example">Example:</h3> <p><code class="language-plaintext highlighter-rouge">addv1 = addv2</code>:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">addv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>      <span class="p">(</span><span class="n">Function</span> <span class="n">evaluation</span><span class="err">.</span><span class="p">)</span>
<span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>   <span class="p">(</span><span class="n">General</span> <span class="n">rule</span><span class="p">:</span> <span class="n">commutativity</span> <span class="n">of</span> <span class="n">addition</span><span class="p">)</span>
<span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>   <span class="p">(</span><span class="n">General</span> <span class="n">rule</span><span class="p">:</span> <span class="n">associativity</span> <span class="n">of</span> <span class="n">addition</span><span class="p">)</span>
<span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="nf">x</span>   <span class="p">(</span><span class="n">General</span> <span class="n">rule</span><span class="p">:</span> <span class="n">evaluation</span> <span class="n">of</span> <span class="n">addition</span><span class="p">)</span>
<span class="o">=</span> <span class="mi">7</span> <span class="o">+</span> <span class="n">x</span>        

  <span class="nf">addv2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>      <span class="p">(</span><span class="n">Function</span> <span class="n">evaluation</span><span class="err">.</span><span class="p">)</span>
<span class="o">=</span> <span class="mi">7</span> <span class="o">+</span> <span class="n">x</span>         
</code></pre></div></div> <h2 id="checking-that-prog-satisfies-the-equations-of-a-category">Checking that <code class="language-plaintext highlighter-rouge">Prog</code> satisfies the equations of a category</h2> <ul> <li><em>(identity right)</em> For any program <code class="language-plaintext highlighter-rouge">fn f(x: A): B</code>, we have that <code class="language-plaintext highlighter-rouge">comp_identityA_f = f</code>. <em>Proof.</em> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    comp_identityA_f(x)   (Function evaluation.)
  = x.identityA().f()     (Function evaluation.)
  = x.f()                 (General rule: method calls are just function calls.)
  = f(x)       
</code></pre></div> </div> </li> <li><em>(identity left)</em> For any program <code class="language-plaintext highlighter-rouge">fn f(x: A): B</code>, we have that <code class="language-plaintext highlighter-rouge">comp_id_identityB = f</code>. <em>Proof.</em> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    comp_f_identityB(x)   (Function evaluation.)
  = x.f().identityA()     (General rule: method calls are just function calls.)
  = identityA(x.f())      (Function evaluation.)
  = x.f()                 
</code></pre></div> </div> </li> <li> <p><em>(associativity)</em> For any program <code class="language-plaintext highlighter-rouge">fn f(x: A): B</code>, <code class="language-plaintext highlighter-rouge">fn g(x: B): C</code>, <code class="language-plaintext highlighter-rouge">fn h(x: C): D</code> we have that the two programs <code class="language-plaintext highlighter-rouge">comp_comp_f_g_h = comp_f_comp_g_h</code> are equivalent.</p> <p>The signature of the two morphisms is <code class="language-plaintext highlighter-rouge">fn f(x: A): D</code>, so it makes sense to ask whether they are equivalent or not.</p> <p><em>Proof.</em></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    comp_comp_f_g_h(x)   (Function evaluation.)
  = x.comp_f_g().h()     (Function evaluation.)
  = (x.f().g()).h()      (General rule: convention selected for method chaining.)
  = x.f().g().h()        

    comp_f_comp_g_h(x)   (Function evaluation.)
  = x.f().comp_g_h()     (Function evaluation.)
  = (x.f()).g().h()      (General rule: convention selected for method chaining.)
  = x.f().g().h()      
</code></pre></div> </div> </li> </ul> <h1 id="we-need-to-add-more-rules-to-our-program-equivalence">We need to add more rules to our program equivalence.</h1> <blockquote> <ol> <li><strong>(Match evaluation.)</strong> <em>When given a <code class="language-plaintext highlighter-rouge">match v with ...</code> expression on a concrete value <code class="language-plaintext highlighter-rouge">v: A</code>, we can reduce the entire expression to the first case that matches by again doing substitution.</em></li> <li><strong>(Case analysis.)</strong> <em>We can reason on all the possible cases that a value of a type can be. If we can prove the same conclusion for all possible cases, we have covered all cases . For example, a list can either be <code class="language-plaintext highlighter-rouge">none()</code> or be <code class="language-plaintext highlighter-rouge">cons(a, as)</code> for some value <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">as</code>.</em></li> </ol> </blockquote> <h1 id="the-category-of-partial-functions-parprog">The category of partial functions <code class="language-plaintext highlighter-rouge">ParProg</code>.</h1> <p>We want to capture the idea that functions can either return a concrete value or fail and return no output. We can do this by defining a new structure that can contain a value of be empty. (You can think of it like a list that can be empty or it can have a single value.)</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nf">none</span><span class="p">()</span>
              <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

<span class="k">fn</span> <span class="nf">giveAnswer</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span><span class="p">):</span> <span class="n">Int</span> <span class="k">=&gt;</span>
    <span class="k">match</span> <span class="n">x</span> <span class="n">with</span>
    <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="mi">42</span>
    <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">42</span>

<span class="k">fn</span> <span class="nf">divide</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span> <span class="k">=&gt;</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="n">then</span>
        <span class="nf">none</span><span class="p">()</span>
    <span class="k">else</span>
        <span class="nf">some</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="c1">// This will never produce an error, so this is a valid Crust program.</span>
</code></pre></div></div> <p>Let’s define the category <code class="language-plaintext highlighter-rouge">ParProg</code> of types and partial functions.</p> <ul> <li><em>(objects)</em> $\text{ParProg}_0$ is the collection of all the types in our current version of <em>Crust</em>.</li> <li><em>(morphisms)</em> Given two types <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code> of <em>Crust</em>, the set $\text{ParProg}($<code class="language-plaintext highlighter-rouge">A</code>$,$<code class="language-plaintext highlighter-rouge">B</code>) is the set of programs of <em>Crust</em> which take one argument of type <code class="language-plaintext highlighter-rouge">A</code> and have <code class="language-plaintext highlighter-rouge">Maybe&lt;B&gt;</code> as return type. <blockquote> <p>Note that equality of morphisms is the same as before.</p> </blockquote> </li> <li><em>(identities)</em> For any given type <code class="language-plaintext highlighter-rouge">A</code>, the identity morphism $\texttt{identity}_\texttt A \in C(A,B)$ is the function <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">identity_A</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">):</span> <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="nf">some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div> </div> <p>In other words, we define the following morphisms:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">identity_Int</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="nf">some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">fn</span> <span class="nf">identity_Str</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">String</span><span class="p">):</span> <span class="n">Maybe</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="nf">some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">fn</span> <span class="nf">identity_Bool</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Bool</span><span class="p">):</span> <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">Bool</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="nf">some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div> </div> </li> <li>(composition) For any two morphisms <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">):</span> <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span>
</code></pre></div> </div> <p>and</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">B</span><span class="p">):</span> <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span>
</code></pre></div> </div> <p>we define their composition to be the morphism</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">comp_f_g</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">):</span> <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="k">=&gt;</span> 
      <span class="k">match</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="n">with</span>
      <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.g</span><span class="p">()</span>
</code></pre></div> </div> <p>Let’s check that the identities hold.</p> </li> <li><em>(identity right)</em> For any program <code class="language-plaintext highlighter-rouge">fn f(x: A): Maybe&lt;B&gt;</code>, we have that <code class="language-plaintext highlighter-rouge">comp_identityA_f = f</code>. <em>Proof.</em> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">comp_identityA_f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>       <span class="p">(</span><span class="n">Function</span> <span class="n">evaluation</span><span class="err">.</span><span class="p">)</span>
  <span class="o">=</span> <span class="k">match</span> <span class="n">x</span><span class="nf">.identityA</span><span class="p">()</span> <span class="nf">with</span>  <span class="p">(</span><span class="n">Function</span> <span class="n">evaluation</span><span class="err">.</span><span class="p">)</span>
    <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
    <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.f</span><span class="p">()</span>   
  <span class="o">=</span> <span class="k">match</span> <span class="nf">some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="nf">with</span>        <span class="p">(</span><span class="n">Match</span> <span class="n">evaluation</span><span class="err">.</span><span class="p">)</span>
    <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
    <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.f</span><span class="p">()</span> 
  <span class="o">=</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span>                   
</code></pre></div> </div> </li> <li><em>(identity left)</em> For any program <code class="language-plaintext highlighter-rouge">fn f(x: A): Maybe&lt;B&gt;</code>, we have that <code class="language-plaintext highlighter-rouge">comp_id_identityB = f</code>. <em>Proof.</em> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">comp_f_identityB</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>   <span class="p">(</span><span class="n">Function</span> <span class="n">evaluation</span><span class="err">.</span><span class="p">)</span>
  <span class="o">=</span> <span class="k">match</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="n">with</span> 
    <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span> 
    <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.identityB</span><span class="p">()</span> 

  <span class="n">Let</span><span class="nv">'s</span> <span class="n">reason</span> <span class="n">by</span> <span class="n">cases</span> <span class="n">on</span> <span class="n">what</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="n">evaluates</span> <span class="n">to</span><span class="py">.

  Case</span> <span class="mf">1.</span> <span class="n">Case</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="o">=</span> <span class="nf">none</span><span class="p">()</span><span class="err">.</span>  
      <span class="o">=</span> <span class="k">match</span> <span class="nf">none</span><span class="p">()</span> <span class="nf">with</span>           <span class="p">(</span><span class="n">Match</span> <span class="n">evaluation</span><span class="p">)</span>
        <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span> 
        <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.identityB</span><span class="p">()</span> 
      <span class="o">=</span> <span class="nf">none</span><span class="p">()</span>                      <span class="p">(</span><span class="n">Assumption</span><span class="p">)</span>
      <span class="o">=</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span>

      <span class="n">Therefore</span><span class="p">,</span> <span class="n">it</span> <span class="n">is</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="py">.

  Case</span> <span class="mf">2.</span> <span class="n">Case</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="o">=</span> <span class="nf">some</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">some</span> <span class="n">value</span> <span class="n">w</span><span class="p">:</span> <span class="n">B</span><span class="err">.</span>
      <span class="o">=</span> <span class="k">match</span> <span class="nf">some</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="nf">with</span>          <span class="p">(</span><span class="n">Match</span> <span class="n">evaluation</span><span class="p">)</span>
        <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span> 
        <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.identityB</span><span class="p">()</span> 
      <span class="o">=</span> <span class="n">w</span><span class="nf">.identityB</span><span class="p">()</span>               <span class="p">(</span><span class="n">Assumption</span><span class="p">)</span>
      <span class="o">=</span> <span class="nf">some</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
      <span class="o">=</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span>

      <span class="n">Therefore</span> <span class="n">it</span> <span class="n">is</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="err">.</span>
</code></pre></div> </div> </li> <li> <p><em>(associativity)</em> For any program <code class="language-plaintext highlighter-rouge">fn f(x: A): Maybe&lt;B&gt;</code>, <code class="language-plaintext highlighter-rouge">fn g(x: B): Maybe&lt;C&gt;</code>, <code class="language-plaintext highlighter-rouge">fn h(x: C): Maybe&lt;D&gt;</code> we have that the two programs <code class="language-plaintext highlighter-rouge">comp_comp_f_g_h = comp_f_comp_g_h</code> are equivalent.</p> <p>The signature of the two morphisms is <code class="language-plaintext highlighter-rouge">fn f(x: A): D</code>, so it makes sense to ask whether they are equivalent or not.</p> <p><em>Proof.</em></p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">comp_comp_f_g_h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>               <span class="p">(</span><span class="n">Function</span> <span class="n">evaluation</span><span class="err">.</span><span class="p">)</span>
  <span class="o">=</span> <span class="k">match</span> <span class="n">x</span><span class="nf">.comp_f_g</span><span class="p">()</span> <span class="nf">with</span>          <span class="p">(</span><span class="n">Function</span> <span class="n">evaluation</span><span class="err">.</span><span class="p">)</span>
    <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
    <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span>     
  <span class="o">=</span> <span class="k">match</span> <span class="p">(</span><span class="k">match</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="n">with</span>
          <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
          <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.g</span><span class="p">())</span> <span class="n">with</span>
    <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
    <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span> 

    <span class="nf">comp_f_comp_g_h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>               <span class="p">(</span><span class="n">Function</span> <span class="n">evaluation</span><span class="err">.</span><span class="p">)</span>
  <span class="o">=</span> <span class="k">match</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="nf">with</span>                 <span class="p">(</span><span class="n">Function</span> <span class="n">evaluation</span><span class="err">.</span><span class="p">)</span>
    <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
    <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.comp_g_h</span><span class="p">()</span>     
  <span class="o">=</span> <span class="k">match</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="nf">with</span>                 <span class="p">(</span><span class="n">Function</span> <span class="n">evaluation</span><span class="err">.</span><span class="p">)</span>
    <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
    <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">v</span><span class="nf">.g</span><span class="p">()</span> <span class="nf">with</span>    <span class="p">(</span><span class="n">Function</span> <span class="n">evaluation</span><span class="err">.</span><span class="p">)</span>
                 <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
                 <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span>

  <span class="n">Consider</span> <span class="n">all</span> <span class="n">possible</span> <span class="n">cases</span> <span class="n">on</span> <span class="n">what</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="n">evaluates</span> <span class="n">to</span><span class="py">.
  Case</span> <span class="n">A</span><span class="py">. Case</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="o">=</span> <span class="nf">none</span><span class="p">()</span><span class="py">.  
    
    The</span> <span class="n">first</span> <span class="n">expression</span> <span class="n">evaluates</span> <span class="n">like</span> <span class="n">this</span><span class="p">:</span>
      <span class="o">=</span> <span class="k">match</span> <span class="p">(</span><span class="k">match</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="n">with</span>
              <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
              <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.g</span><span class="p">())</span> <span class="n">with</span>
      <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span> 
      <span class="o">=</span> <span class="k">match</span> <span class="p">(</span><span class="k">match</span> <span class="nf">none</span><span class="p">()</span> <span class="n">with</span>
              <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
              <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.g</span><span class="p">())</span> <span class="n">with</span>
      <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span> 
      <span class="o">=</span> <span class="k">match</span> <span class="nf">none</span><span class="p">()</span> <span class="n">with</span>
      <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span> 
      <span class="o">=</span> <span class="nf">none</span><span class="p">()</span>

    <span class="n">The</span> <span class="n">second</span> <span class="n">expression</span> <span class="n">evaluates</span> <span class="n">like</span> <span class="n">this</span><span class="p">:</span>
      
      <span class="o">=</span> <span class="k">match</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="n">with</span>                
      <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">v</span><span class="nf">.g</span><span class="p">()</span> <span class="n">with</span>   
                   <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
                   <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span>
      <span class="o">=</span> <span class="k">match</span> <span class="nf">none</span><span class="p">()</span> <span class="n">with</span>                
      <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">v</span><span class="nf">.g</span><span class="p">()</span> <span class="n">with</span>   
                   <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
                   <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span>
      <span class="o">=</span> <span class="nf">none</span><span class="p">()</span>

    <span class="n">So</span> <span class="n">the</span> <span class="n">functions</span> <span class="n">agree</span> <span class="k">in</span> <span class="n">this</span> <span class="n">case</span><span class="py">.
    
  Case</span> <span class="mf">2.</span> <span class="n">Case</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="o">=</span> <span class="nf">some</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">some</span> <span class="n">value</span> <span class="n">w</span><span class="p">:</span> <span class="n">B</span><span class="py">.
        
      The</span> <span class="n">first</span> <span class="n">expression</span> <span class="n">evaluates</span> <span class="n">like</span> <span class="n">this</span><span class="p">:</span>

      <span class="o">=</span> <span class="k">match</span> <span class="p">(</span><span class="k">match</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="n">with</span>
              <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
              <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.g</span><span class="p">())</span> <span class="n">with</span>
      <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span> 
      <span class="o">=</span> <span class="k">match</span> <span class="p">(</span><span class="k">match</span> <span class="nf">some</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="n">with</span>
              <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
              <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.g</span><span class="p">())</span> <span class="n">with</span>
      <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span> 
      <span class="o">=</span> <span class="k">match</span> <span class="n">w</span><span class="nf">.g</span><span class="p">()</span> <span class="n">with</span>
      <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span> 
        
    <span class="n">The</span> <span class="n">second</span> <span class="n">expression</span> <span class="n">evaluates</span> <span class="n">like</span> <span class="n">this</span><span class="p">:</span>
        
      <span class="o">=</span> <span class="k">match</span> <span class="n">x</span><span class="nf">.f</span><span class="p">()</span> <span class="n">with</span>                
      <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">v</span><span class="nf">.g</span><span class="p">()</span> <span class="n">with</span>   
                   <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
                   <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span>
      <span class="o">=</span> <span class="k">match</span> <span class="nf">some</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="n">with</span>                
      <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">v</span><span class="nf">.g</span><span class="p">()</span> <span class="n">with</span>   
                   <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
                   <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span>
      <span class="o">=</span> <span class="k">match</span> <span class="n">w</span><span class="nf">.g</span><span class="p">()</span> <span class="n">with</span>   
      <span class="p">|</span> <span class="nf">none</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="nf">none</span><span class="p">()</span>
      <span class="p">|</span> <span class="nf">some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="nf">.h</span><span class="p">()</span>
                
    <span class="n">So</span> <span class="n">the</span> <span class="n">functions</span> <span class="n">agree</span> <span class="k">in</span> <span class="n">this</span> <span class="n">case</span> <span class="k">as</span> <span class="n">well</span><span class="err">.</span>
</code></pre></div> </div> </li> </ul> <h1 id="the-unit-type">The unit type</h1> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Unit</span> <span class="o">=</span> <span class="nf">unit</span><span class="p">()</span>

<span class="k">fn</span> <span class="nf">toUnit_Int</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Unit</span> <span class="k">=&gt;</span> <span class="nf">unit</span><span class="p">()</span>
<span class="k">fn</span> <span class="nf">toUnit_Str</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Str</span><span class="p">):</span> <span class="n">Unit</span> <span class="k">=&gt;</span> <span class="nf">unit</span><span class="p">()</span>
<span class="k">fn</span> <span class="nf">toUnit_Bool</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Bool</span><span class="p">):</span> <span class="n">Unit</span> <span class="k">=&gt;</span> <span class="nf">unit</span><span class="p">()</span>

<span class="c1">// Alternatively, we could have defined it uniformly with a parametric schema:</span>

<span class="k">fn</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">toUnit</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Unit</span> <span class="k">=&gt;</span> <span class="nf">unit</span><span class="p">()</span>

<span class="k">fn</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">justAnswer</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Unit</span><span class="p">):</span> <span class="n">Int</span> <span class="k">=&gt;</span> 
    <span class="k">match</span> <span class="n">a</span> <span class="n">with</span>
    <span class="p">|</span> <span class="nf">unit</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="mi">42</span>
</code></pre></div></div> <p>Notice the following:</p> <blockquote> <p>Given any type <code class="language-plaintext highlighter-rouge">A</code>, there is a morphism <code class="language-plaintext highlighter-rouge">fn toUnit(x: A): Unit</code>. Moreover, any morphism <code class="language-plaintext highlighter-rouge">fn f(a: A): Unit</code> is equivalent to <code class="language-plaintext highlighter-rouge">toUnit</code>.</p> </blockquote> <p><em>Proof.</em></p> <p>The morphism is <code class="language-plaintext highlighter-rouge">toUnit_A</code>. Let’s assume to have another morphism <code class="language-plaintext highlighter-rouge">f</code> and let’s see that it’s equal to <code class="language-plaintext highlighter-rouge">toUnit_A</code>.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  f(a)       (General rule: there is no other option for `Unit`.)
= unit()         

  toUnit(x)  (Function evaluation.)
= unit()
</code></pre></div></div> <h1 id="the-empty-type">The Empty type</h1> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// No constructor!</span>
<span class="k">type</span> <span class="n">Empty</span> 

<span class="k">fn</span> <span class="nf">fromEmpty_Int</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Empty</span><span class="p">):</span> <span class="n">Int</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">a</span> <span class="n">with</span> 
<span class="k">fn</span> <span class="nf">fromEmpty_Str</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Empty</span><span class="p">):</span> <span class="n">Str</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">a</span> <span class="n">with</span> 
<span class="k">fn</span> <span class="nf">fromEmpty_Bool</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Empty</span><span class="p">):</span> <span class="n">Bool</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">a</span> <span class="n">with</span> 

<span class="c1">// Alternatively, we could have defined it with a parametric schema:</span>

<span class="k">fn</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">fromEmpty</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Empty</span><span class="p">):</span> <span class="n">A</span> <span class="k">=&gt;</span> 
  <span class="k">match</span> <span class="n">a</span> <span class="n">with</span> 

<span class="cm">/*
This is a valid Crust program!
The `match` construct needs one case for each possible way of constructing the type that it's matching on. In this case, there are no possible ways of constructing something of type Empty, so it is okay to simply put no cases in our match expression.
Note that the return type is allowed to be any type A because no concrete value needs to be provided, so it works with any type.
*/</span>
</code></pre></div></div> <p>Let’s prove the following:</p> <blockquote> <p>Given any type <code class="language-plaintext highlighter-rouge">A</code>, there is a morphism <code class="language-plaintext highlighter-rouge">fn fromEmpty_A(x: Empty): A</code>. Moreover, any morphism <code class="language-plaintext highlighter-rouge">fn f(a: Empty): A</code> is equivalent to <code class="language-plaintext highlighter-rouge">fromEmpty_A</code>.</p> </blockquote> <p>The morphism is <code class="language-plaintext highlighter-rouge">fromEmpty_A</code>. Let’s assume to have another morphism <code class="language-plaintext highlighter-rouge">f</code> and let’s see that it’s equal to <code class="language-plaintext highlighter-rouge">fromEmpty_A</code>.</p> <p><em>Proof.</em></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Recall the definition of program equivalence.

&gt; **Program equivalence:** given two types `A` and `B` two programs `fn f(x: A): B` and `fn g(x: A): B`, we say that they are *equal* (written `f = g`) when: *for every value `x` of type `A`, the two calls `f(x)` and `g(x)` return the same value*.

Therefore, we need to check that for every value `x` of type `Empty` the values `fromEmpty_A(x)` and `f(x)` are the same.

There is no value of type `Empty`, therefore we have already checked that in every possible case the values of the two functions is the same, so we are done.
</code></pre></div></div> <h1 id="unit-is-not-a-terminal-object-in-parprog"><code class="language-plaintext highlighter-rouge">Unit</code> is not a terminal object in <code class="language-plaintext highlighter-rouge">ParProg</code>.</h1> <blockquote> <p><strong>Unit is NOT the terminal object of <code class="language-plaintext highlighter-rouge">Prog</code>.</strong> Given any type <code class="language-plaintext highlighter-rouge">A</code>, there is a morphism <code class="language-plaintext highlighter-rouge">fn toUnit(x: A): Maybe&lt;Unit&gt;</code>. Moreover, <em>NOT EVERY</em> morphism <code class="language-plaintext highlighter-rouge">fn f(a: A): Maybe&lt;Unit&gt;</code> is equivalent to <code class="language-plaintext highlighter-rouge">toUnit</code>; that is, there are at least two morphisms which are not equivalent.</p> </blockquote> <p><em>Proof.</em></p> <p>The two morphisms are the following:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn toUnit1(x: A): Maybe&lt;Unit&gt; =&gt; some(unit())
fn toUnit2(x: A): Maybe&lt;Unit&gt; =&gt; none()
</code></pre></div></div> <p>They are clearly not equivalent.</p> <h1 id="empty-is-the-initial-object-in-parprog"><code class="language-plaintext highlighter-rouge">Empty</code> is the initial object in <code class="language-plaintext highlighter-rouge">ParProg</code>.</h1> <script type="text/javascript" src="js/jquery.min.js"/></script> <script type="text/javascript" src="js/jquery.scrollme.min.js"/></script> <script type="text/javascript" src="js/stickUp.min.js"/></script> <script type="text/javascript" src="js/fchoue.js"/></script> <script type="text/javascript" src="js/bibtex-copy-button.js"/></script> </body> </html>
